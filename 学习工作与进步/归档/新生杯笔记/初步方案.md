# 初步方案设计报告

## 功能描述

概述：

小车由手机或电脑远程蓝牙控制运动，向台阶前进过程中如果探测到正前方有扫地机器人或者靠近台阶时，会自动发出警报。
登上台阶后，依次靠近三个平台收集糖果并储存在车筐中后，下台阶返回到出发区域。

该过程中涉及五种基本功能，各项功能对应结构和实现方式如下表所示

功能| 对应结构 |实现方式
-|:-:|:-
遥控|开发板|在手机上安装蓝牙串口驱动，与小车上的开发板配对后，单片机通过读取手机发来的蓝牙信号，执行相应的指令，控制小车的移动和停止
运动|开发板、车轮（或履带）及其驱动装置|开发板与电机连接后，通过开发板内置程序对电机进行控制，以恒定（可选择变速）速度移动、停止。两侧电机可以分别进行控制，实现转向
探测|开发板、探测模块|小车前端装有超声波/红外模块，探测模块连接上开发板后，输入距离信息，由开发板进行处理，判断正前方障碍物的情况，执行相应指令
报警|开发板、蜂鸣器|开发板与蜂鸣器连接，满足触发条件后，驱动蜂鸣器发出警报
收集与储存|开发板、机械臂及其驱动装置、车框|（1）车筐为月牙形（如图）的小车贴近放置糖果的圆柱平台，使车筐与平台吻合。（2）旋转控制机械臂顶端搭在平台末尾，控制机械臂在滑轨上整体横向移动，将糖果扫到车框内（3）车身后退一定距离使车筐离开圆柱平台，移动到下一平台附近重复以上操作。

（附上四张机械臂不同状态的图片1，2，3，4）


## 结构设计

概述

根据功能要求，小车由如下几部分部分组成，每部分对应的模块和实现方式如下表所示。各部分结构由螺丝、滚轴或强力胶连接。

（附上小车全貌图片5）

> 为了实现上楼梯要求，同时尽量缩小体积和实现难度，我们小组采用楔形履带的设计，让履带的尖端能直接到达台阶上端，从而带动整个小车翻上台阶。

> 同样，为了实现收集糖果的要求，同时尽量减少实现难度，我们小组将机械臂设计成单一关节，能较简单地控制机械臂顶端贴合平台顶面。接着为了实现扫下糖果的功能，在机械臂底端加装了可以水平移动的导轨，用两组电机实现收集糖果的功能。

结构|描述|对应模块或材料|实现方式
-|:-|:-|:-
车身|安装、连接小车的基础部分|金属板材或亚克力板|淘宝购买、工训中心进行切割
车筐|月牙形，能贴合糖果所在圆柱体|亚克力板|淘宝购买、工训中心进行切割
开发板|信息处理、接受命令、发出指令|ESP32开发板、面包板、杜邦线、航模电源|淘宝购买
车轮（或履带）及其驱动装置|包含电机、自行设计的车轮结构（或履带结构）|车轮（或履带）、电机|淘宝购买
机械臂及其驱动装置|含有舵机，安装在小车两侧，连接导轨可以水平平移|金属板材、亚克力板、步进电机（或者舵机）|淘宝购买、工训中心进行切割
探测模块|测量距离|超声波/红外模块|淘宝购买
蜂鸣器|发出警报|蜂鸣器模块|淘宝购买

## 模块清单

* 直流电机
* 直流电机
* 舵机
* 超声波、红外模块
* 蜂鸣器

### 蓝牙模块（ESP32开发板自带）

通过自带的蓝牙模块，开发板可以从手机和电脑远程接受指令。

实现代码：用手机蓝牙控制RGB小灯的亮灭,开发板接受1则点亮，接受0则熄灭小灯

``` C++
#include "BluetoothSerial.h"

#if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED)
#error Bluetooth is not enabled! Please run `make menuconfig` to and enable it
#endif

uint8_t ledR = 5, ledG = 18, ledB = 19; 
uint8_t command=0; //命令变量初始化
uint8_t ledArray[3] = {1, 2, 3}; 

BluetoothSerial SerialBT;

void setup() {
    Serial.begin(115200);
    SerialBT.begin("ESP32test"); //Bluetooth device name
    Serial.println("The device started, now you can pair it with bluetooth!");
    delay(10); 
  
    ledcAttachPin(ledR, 1);
    ledcAttachPin(ledG, 2);
    ledcAttachPin(ledB, 3);
 
    ledcSetup(1, 12000, 8); // 12 kHz PWM, 8-bit resolution
    ledcSetup(2, 12000, 8);
    ledcSetup(3, 12000, 8);
}

void loop() {
    if (Serial.available()) {
        SerialBT.write(Serial.read());
    }
    if (SerialBT.available()) {
        command=SerialBT.read();
    }
    if(command==49){
        ledcWrite(1, 255);
        ledcWrite(2, 255);
        ledcWrite(3, 255);
    }
    elif(command==48){
        ledcWrite(1, 0);
        ledcWrite(2, 0);
        ledcWrite(3, 0);
    }
}
```


### 直流电机

详细信息：

步进电机     
* 7.9元
* 直径：28mm
* 电压：5V
* 步进角度：5.625*1/64
* 减速比：1/64
* https://m.tb.cn/h.eaJI3Xv?sm=3e1df4 

TT马达      
* 8元
* 70.5*27*23mm
* 速比：1：48   1：120
* 转速：100r/min
* 电压：3-6V
* https://m.tb.cn/h.3AvqOaf?sm=9d9e14 

实现代码：包括头文件、引脚初始化语句、输出语句
```C++
int leftMotor1 = 16;
int leftMotor2 = 17;
int rightMotor1 = 18;
int rightMotor2 = 19;
void setup() {
  pinMode(leftMotor1, OUTPUT);
  pinMode(leftMotor2, OUTPUT);
  pinMode(rightMotor1, OUTPUT);
  pinMode(rightMotor2, OUTPUT);
  
}
void loop() {
int cmd;
  for(cmd=0;cmd<5;cmd++
  {
    motorRun(cmd);  
    delay(2000);
  } 
}
void motorRun(int cmd){
  switch(cmd){
    case FORWARD:
      digitalWrite(leftMotor1, LOW);
      digitalWrite(leftMotor2, HIGH);
      digitalWrite(rightMotor1, LOW);
      digitalWrite(rightMotor2, HIGH);
      break;
     case BACKWARD:
      digitalWrite(leftMotor1, HIGH);
      digitalWrite(leftMotor2, LOW);
      digitalWrite(rightMotor1, HIGH);
      digitalWrite(rightMotor2, LOW);
      break;
     case TURNLEFT:
      digitalWrite(leftMotor1, HIGH);
      digitalWrite(leftMotor2, LOW);
      digitalWrite(rightMotor1, LOW);
      digitalWrite(rightMotor2, HIGH);
      break;
     case TURNRIGHT:
      digitalWrite(leftMotor1, LOW);
      digitalWrite(leftMotor2, HIGH);
      digitalWrite(rightMotor1, HIGH);
      digitalWrite(rightMotor2, LOW);
      break;
     default:
      digitalWrite(leftMotor1, LOW);
      digitalWrite(leftMotor2, LOW);
      digitalWrite(rightMotor1, LOW);
      digitalWrite(rightMotor2, LOW);
  }
}
```


### 舵机

详细信息：

* SG90 9g舵机 
* 价格：12.8元
* 电压：4.8V-6.0V
* 速度：4.8V@0.12sec/60。6.0V@0.11sec/。
* 扭力：4.8V@1.5kg-cm
     6.0V@1.7kg-cm
* https://m.tb.cn/h.eaJxhGc?sm=d635a8 

实现代码：包括头文件、引脚初始化语句、输出语句
```C++
Servo servo1;
Servo servo2;
int servo1pin=34;
int servo2pin=35;
int pos=0;
Int angel=0;
int minus=500;
int maxus= z400;
void setup(){
  Servo1.attach(servo1Pin,minus,maxus);
  Servo1.attach(servo2Pin,minus,maxus);
}
void loop(){
     angel=serialBT.read(); //与蓝牙指令功能匹配读入角度
    //if(command){   command为蓝牙指令
    steer();
    //}
    //if(!command){
    back();
    //}
  
}
void steer(){
   for(pose=0;pose<angel;pos++){
    servo1.write(pos);
    servo2.write(pos);
    delay(20);  
  }
}
void back(){
   for(pose=angel;pose>0;pos--){
    servo1.write(pos);
    servo2.write(pos);
    delay(20);  
  }
}

```
### 超声波/红外模块


超声波模块     
 * 价格：7.9元
 * 使用电压：DC5V
 * 静态电流：小于2mA
 * 电平输出：5V～0V        
 * 感应角度：不大于15度        
 * 探测距离：2cm-450cm      
 * 精度：可达0.3cm
 * 链接
 https://detail.tmall.com/item.htm?spm=a1z10.3-b-s.w4011-15386465886.29.508c184crXK7BV&id=551217215163&rn=36815466ff3acf888aaee13b73901a83&abbucket=3


使用代码：包括头文件、引脚初始化语句、模块输入输出语句
```C++
const int TrigPin = 2; 
const int EchoPin = 3; 
float cm; 
void setup() 
{ 
Serial.begin(9600); 
pinMode(TrigPin, OUTPUT); 
pinMode(EchoPin, INPUT); 
} 
void loop() 
{ 
digitalWrite(TrigPin, LOW); 
delayMicroseconds(2); 
digitalWrite(TrigPin, HIGH); 
delayMicroseconds(10); 
digitalWrite(TrigPin, LOW); 

cm = pulseIn(EchoPin, HIGH) / 58.0;
cm = (int(cm * 100.0)) / 100.0;
Serial.print("Distance:"); 
Serial.print(cm); 
Serial.print("cm"); 
Serial.println(); 
delay(1000); 
}
```
### 蜂鸣器

* 有源蜂鸣器9650
* 价格：1.05元
* 使用电压：3V/5V     
* 尺寸：9.6*9.6*5mm
* 链接
https://m.tb.cn/h.ea8Qr0I?sm=42a136 

使用代码：包括头文件、引脚初始化语句、模块使用语句
```C++
int freq = 2000;
int channel = 0;
int resolution = 8;
void setup() {
Serial.begin(115200);
ledcSetup(channel, freq, resolution);
ledcAttachPin(12, channel);
}
void loop() {
ledcWriteTone(channel, 2000);
for (int dutyCycle = 0; dutyCycle <= 255; dutyCycle=dutyCycle+10){
Serial.println(dutyCycle);
ledcWrite(channel, dutyCycle);
delay(1000);
}
ledcWrite(channel, 125);
for (int freq = 255; freq < 10000; freq = freq + 250){
Serial.println(freq);
ledcWriteTone(channel, freq);
delay(1000);
}
}
```


