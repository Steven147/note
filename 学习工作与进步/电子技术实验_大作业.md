# 实验报告：四位二进制数的可控加法/减法FPGA设计

## 设计结果

使用Vivado2017编程以及相应开发板，实现了基本的二进制加减法计算器的实现。


## 详细叙述设计方案和设计过程

基本功能：输入两个四位二进制数，按下运算按钮后，以用数码管的方式显示运算的结果。

基本操作：

    * 数字输入操作：采用两个微动开关，分别代表数字0与数字1的输入按键，输入逻辑与普通计算器相同：逐个输入，即按下数字按钮，先前已经输入的数字会向前推进一位。
    * 运算操作：在输入完成第一个数字之后，摁下代表加法或者减法的按键，便可以开始输入第二个数字，在输入完第二个数字后，摁下代表运算（count）的按键，便可以在数码管上显示计算结果。
    * 清零操作：在一次计算完成后，或者是输入了错误的数字，需要摁下代表清零（clr）的按键，计算器会立即重置，开始等待第一个数字的输入。

显示：

    * 在摁下数字输入按键时，后四位数码管会实时显示已经输入的数字。如果输入的数字超出了四位，则会继续向前推进，只取后四位进行运算。
    * 在摁下运算（count）按键时，后四位数码管会立刻显示计算结果。如果运算结果大于或小于四位二进制数能够显示的最大范围（即0-15），会在最后一个数码管显示E。

1．在基本功能实现前提下，增加一个清零功能。
2．更换显示方式，结果进行显示。
3．对溢出值的考虑。如果发生溢出现象，则数码管显示“E”。
4．放弃拨码开关的输入方式，按照算式方法输入。两个微动开关代表“1”和“0”，
两个开关代表“＋”和“－”，还有一个开关代表“＝”。比如要算 0000＋1111，
就按顺序输入这些数字和运算符，同时数码管动态显示输入值，等按下“＝”
后显示结果。用点阵显示运算符。

## 画出完整的顶层逻辑设计图

## 写出每一个文本文件的源程序

> binaryAdder.v 程序文件

```
module D0_display( //ע�Ͳο�ʵ��һ
    input [3:0] D0_bits ,
    input [3:0] D0_NUM ,
    output reg [6:0] D0_a_to_g ,
    output [3:0] D0_led_bits
    );
    
    assign D0_led_bits = D0_bits ;
    
    always @(*)
    begin
        case(D0_NUM)
        0:D0_a_to_g=7'b1111110;
        1:D0_a_to_g=7'b0110000;
        //2:D0_a_to_g=7'b1101101;
        //3:D0_a_to_g=7'b1111001;   
        //4:D0_a_to_g=7'b0110011;
        //5:D0_a_to_g=7'b1011011;
        //6:D0_a_to_g=7'b1011111;
        //7:D0_a_to_g=7'b1110000;
        //8:D0_a_to_g=7'b1111111;
        //9:D0_a_to_g=7'b1111011;
        //'hA: D0_a_to_g=7'b1110111;
        //'hB: D0_a_to_g=7'b0011111;
        //'hC: D0_a_to_g=7'b1001110;
        //'hD: D0_a_to_g=7'b0111101;
        'hE: D0_a_to_g=7'b1001111;
        //'hF: D0_a_to_g=7'b1000111;
        default: D0_a_to_g=7'b0000000;
        endcase
    end
endmodule

module Count_FFFF( //ע�Ͳο�ʵ���
    input clk,
    input clr,
     
    input one, 
    input zero,
    input add,
    input sub, 
    input count,
     
    output [6:0] a_to_g ,
    output [3:0] led_bits
    );
    reg [3:0] num ;//���浥�����������Ҫ��ʾ������
    reg [35:0] ckl_cnt; 
    reg [3:0] t_led_bits ; //�м�������洢����ܸ����л�λ����Ϣ
    reg [3:0] number1 = 0;//�������������
    reg [3:0] number2 = 0;//�������������
    reg [3:0] value = 0; 
    reg [1:0] state = 1;
    reg func = 0;
    reg flag = 1;
 
    always@(posedge clk)
    begin
        ckl_cnt = ckl_cnt + 1 ;
        
        if(state)//�ڼ�⵽һ���������ʱ��¼����
        begin
            if(one)
            begin
                if(flag)
                begin
                    number1[3] = number1[2];
                    number1[2] = number1[1];
                    number1[1] = number1[0];
                    number1[0] = 1;
                    value = number1;
                    flag = 0;
                end
            end
            else if(zero) 
            begin 
                if(flag)
                begin
                    number1[3] = number1[2]; 
                    number1[2] = number1[1];
                    number1[1] = number1[0];
                    number1[0] = 0;
                    value = number1;
                    flag = 0;
                 end
            end
            else flag = 1;
        end
        else//���Ϊ�� ��¼��ĩβ
        begin
            if(one)
            begin
                if(flag)
                begin
                    number2[3] = number2[2];
                    number2[2] = number2[1];
                    number2[1] = number2[0];
                    number2[0] = 1;
                    value = number2;
                    flag = 0;
                end
            end
            else if(zero) 
            begin 
                if(flag)
                begin
                    number2[3] = number2[2]; 
                    number2[2] = number2[1];
                    number2[1] = number2[0];
                    number2[0] = 0;
                    value = number2;
                    flag = 0;
                 end
            end
            else flag = 1;
        end      
        
        if(add)
        begin 
            state = 0;
            func = 1;
        end
        else if(sub)
        begin
            state = 0;
            func = 0;
        end
        
        else if(count)
        begin
            if (func) value = number1 + number2;
            else value = number1 - number2;
        end
        else if(clr)
        begin
            if (func) value = number1 + number2;
            else value = number1 - number2;
            state = 1;
            value = 0;
            number1 = 0;
            number2 = 0;
        end
    end
 
    always@(*) //ȡ���������ĸ� 16 λ���Ҫ��ʾ�� 1 �� 4 λʮ��������
        case(ckl_cnt[15:14]) //ȡ���������Ľϵ� 2 λ(Ƶ�ʸ�)��ֵ����Ϊ 4 λ�����ɨ�踴λ�л�Ƶ��
        0:begin num <= value[0]; t_led_bits <= 4'b0001;end //����� 1 ��Ч��
        1:begin num <= value[1];t_led_bits <= 4'b0010;end //����� 2 ��Ч��
        2:begin num <= value[2];t_led_bits <= 4'b0100;end //����� 3 ��Ч��
        3:begin num <= value[3];t_led_bits <= 4'b1000;end //����� 4 ��Ч��
        endcase
  
    D0_display myD0_display(.D0_bits(t_led_bits),.D0_NUM(num),.D0_a_to_g(a_to_g),.D0_led_bits(led_bits)) ;
endmodule
```

> ee.xdc 引脚定义文件
```
set_property PACKAGE_PIN D4 [get_ports {a_to_g[6]}]
set_property PACKAGE_PIN E3 [get_ports {a_to_g[5]}]
set_property PACKAGE_PIN D3 [get_ports {a_to_g[4]}]
set_property PACKAGE_PIN F4 [get_ports {a_to_g[3]}]
set_property PACKAGE_PIN F3 [get_ports {a_to_g[2]}]
set_property PACKAGE_PIN E2 [get_ports {a_to_g[1]}]
set_property PACKAGE_PIN D2 [get_ports {a_to_g[0]}]
set_property PACKAGE_PIN G1 [get_ports {led_bits[3]}]
set_property PACKAGE_PIN F1 [get_ports {led_bits[2]}]
set_property PACKAGE_PIN E1 [get_ports {led_bits[1]}]
set_property PACKAGE_PIN G6 [get_ports {led_bits[0]}]
set_property PACKAGE_PIN P17 [get_ports clk]
set_property IOSTANDARD LVCMOS33 [get_ports {a_to_g[6]}]
set_property IOSTANDARD LVCMOS33 [get_ports {a_to_g[5]}]
set_property IOSTANDARD LVCMOS33 [get_ports {a_to_g[4]}]
set_property IOSTANDARD LVCMOS33 [get_ports {a_to_g[3]}]
set_property IOSTANDARD LVCMOS33 [get_ports {a_to_g[2]}]
set_property IOSTANDARD LVCMOS33 [get_ports {a_to_g[1]}]
set_property IOSTANDARD LVCMOS33 [get_ports {a_to_g[0]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led_bits[3]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led_bits[2]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led_bits[1]}]
set_property IOSTANDARD LVCMOS33 [get_ports {led_bits[0]}]
set_property IOSTANDARD LVCMOS33 [get_ports clk]
set_property IOSTANDARD LVCMOS33 [get_ports clr]

set_property PACKAGE_PIN V1 [get_ports one]
set_property PACKAGE_PIN R17 [get_ports sub]
set_property IOSTANDARD LVCMOS33 [get_ports add]
set_property IOSTANDARD LVCMOS33 [get_ports count]
set_property IOSTANDARD LVCMOS33 [get_ports one]
set_property IOSTANDARD LVCMOS33 [get_ports sub]
set_property IOSTANDARD LVCMOS33 [get_ports zero]

set_property PACKAGE_PIN U4 [get_ports add]
set_property PACKAGE_PIN R15 [get_ports count]


set_property PACKAGE_PIN R11 [get_ports zero]



set_property PACKAGE_PIN R1 [get_ports clr]

```

## 详细叙述调试中所碰到的问题及解决方案

困难一：在分配clear变量和count变量的引脚时出现错误

``` 
[Place 30-876] Port 'clr'  is assigned to PACKAGE_PIN 'R15'  which can only be used as the N side of a differential clock input. 
Please use the following constraint(s) to pass this DRC check:
set_property CLOCK_DEDICATED_ROUTE FALSE [get_nets {clr_IBUF}]
```
```
[Place 30-574] Poor placement for routing between an IO pin and BUFG. If this sub optimal condition is acceptable for this design, you may use the CLOCK_DEDICATED_ROUTE constraint in the .xdc file to demote this message to a WARNING. However, the use of this override is highly discouraged. These examples can be used directly in the .xdc file to override this clock rule.
	< set_property CLOCK_DEDICATED_ROUTE FALSE [get_nets switch_IBUF] >

	switch_IBUF_inst (IBUF.O) is locked to IOB_X0Y49
	 and switch_IBUF_BUFG_inst (BUFG.I) is provisionally placed by clockplacer on BUFGCTRL_X0Y16
```

问题解决：不可以将clr等变量放在always@的参数列表里，统一把函数定义在时钟函数里



困难二：syntax error near else

begin end 的使用条件

## 试验后的心得



