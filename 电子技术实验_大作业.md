# 实验报告

## 详细叙述设计方案和设计过程

## 画出完整的顶层逻辑设计图

## 写出每一个文本文件的源程序

## 详细叙述调试中所碰到的问题及解决方案

困难一：在分配clear变量和count变量的引脚时出现错误

``` 
[Place 30-876] Port 'clr'  is assigned to PACKAGE_PIN 'R15'  which can only be used as the N side of a differential clock input. 
Please use the following constraint(s) to pass this DRC check:
set_property CLOCK_DEDICATED_ROUTE FALSE [get_nets {clr_IBUF}]
```
```
[Place 30-574] Poor placement for routing between an IO pin and BUFG. If this sub optimal condition is acceptable for this design, you may use the CLOCK_DEDICATED_ROUTE constraint in the .xdc file to demote this message to a WARNING. However, the use of this override is highly discouraged. These examples can be used directly in the .xdc file to override this clock rule.
	< set_property CLOCK_DEDICATED_ROUTE FALSE [get_nets switch_IBUF] >

	switch_IBUF_inst (IBUF.O) is locked to IOB_X0Y49
	 and switch_IBUF_BUFG_inst (BUFG.I) is provisionally placed by clockplacer on BUFGCTRL_X0Y16
```


困难二：syntax error near else

begin end 的使用条件

## 试验后的心得



``` C
`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2019/09/23 14:54:30
// Design Name: 
// Module Name: display
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module  D0_display(
    input [3:0] D0_bits,
    input [3:0] D0_NUM, 
    output reg [7:0] D0_a_to_g ,
    output [3:0] D0_led_bits 
    );
    assign D0_led_bits = D0_bits ; 
    always @(*)
    begin
        case(D0_NUM)
        0:D0_a_to_g=8'b11111100;
        1:D0_a_to_g=8'b01100000;     
        2:D0_a_to_g=8'b11011010;     
        3:D0_a_to_g=8'b11110010;     
        4:D0_a_to_g=8'b01100110;     
        5:D0_a_to_g=8'b10110110;     
        6:D0_a_to_g=8'b10111110;     
        7:D0_a_to_g=8'b11100000;     
        8:D0_a_to_g=8'b11111110;     
        9:D0_a_to_g=8'b11110110;     
        'hA: D0_a_to_g=8'b11101110;     
        'hB: D0_a_to_g=8'b00111110;    
        'hC: D0_a_to_g=8'b10011100;     
        'hD: D0_a_to_g=8'b01111010;     
        'hE: D0_a_to_g=8'b10011110;     
        'hF: D0_a_to_g=8'b10001110;    
        default: D0_a_to_g=8'b11111100;  
        endcase
    end
endmodule

module Count_FFFF(            //注释参考实验二     
    input clk,     
    input clr, 
    input switch,
    //input add,
   // input sub,
    input [7:0] number,    
    output [7:0] a_to_g ,     
    output [3:0] led_bits     
    );    
    reg [3:0]  num ;
    reg [7:0]  num2 ; 
    reg [1:0]  switch_num ; 
    reg [35:0] ckl_cnt ;     
    reg [3:0] t_led_bits ;         //中间变量，存储数码管复用切换位控信息    

     always@(posedge clk)     
     begin     
     if(clr) 
        begin
        ckl_cnt = 0 ;
        num2[4:0] = number[7:4] + number[3:0];
        end
     else      
        ckl_cnt = ckl_cnt + 1 ;   
     end 
           
     always@(posedge switch)     
          begin      
             switch_num = switch_num + 1 ;   
          end   
     
     always@(*)                //取计数变量的高 16 位组成要显示的 1 个 4 位十六进制数     
        case(switch_num)         //在2/8/10/16进制中切换     
             0: case(ckl_cnt[15:14])         //取计数变量的较低 2 位(频率高)数值，作为 4 位数码管扫描复位切换频率     
                0:begin num = num2[0:0];t_led_bits <= 4'b0001;end    //数码管 1 有效，且显示数值为最低 4 位     
                1:begin num = num2[1:1];t_led_bits <= 4'b0010;end    //数码管 2 有效，且显示数值为次低 4 位     
                2:begin num = num2[2:2];t_led_bits <= 4'b0100;end    //数码管 3 有效，且显示数值为次高 4 位     
                3:begin num = num2[3:3];t_led_bits <= 4'b1000;end    //数码管 4 有效，且显示数值为最高 4 位     
                endcase    //数码管 1 有效，且显示数值为最低 4 位     
             1: case(ckl_cnt[15:14])         //取计数变量的较低 2 位(频率高)数值，作为 4 位数码管扫描复位切换频率     
                0:begin num = 0;t_led_bits <= 4'b0001;end    //数码管 1 有效，且显示数值为最低 4 位     
                1:begin num = 0;t_led_bits <= 4'b0010;end    //数码管 2 有效，且显示数值为次低 4 位     
                2:begin num = 0;t_led_bits <= 4'b0100;end    //数码管 3 有效，且显示数值为次高 4 位     
                3:begin num = 0;t_led_bits <= 4'b1000;end    //数码管 4 有效，且显示数值为最高 4 位     
                endcase    //数码管 2 有效，且显示数值为次低 4 位     
             2: case(ckl_cnt[15:14])         //取计数变量的较低 2 位(频率高)数值，作为 4 位数码管扫描复位切换频率     
                0:begin num = 0;t_led_bits <= 4'b0001;end    //数码管 1 有效，且显示数值为最低 4 位     
                1:begin num = 0;t_led_bits <= 4'b0010;end    //数码管 2 有效，且显示数值为次低 4 位     
                2:begin num = 0;t_led_bits <= 4'b0100;end    //数码管 3 有效，且显示数值为次高 4 位     
                3:begin num = 0;t_led_bits <= 4'b1000;end    //数码管 4 有效，且显示数值为最高 4 位     
                endcase    //数码管 3 有效，且显示数值为次高 4 位     
             3: case(ckl_cnt[15:14])         //取计数变量的较低 2 位(频率高)数值，作为 4 位数码管扫描复位切换频率     
                0:begin num = num2[3:0];t_led_bits <= 4'b0001;end    //数码管 1 有效，且显示数值为最低 4 位     
                1:begin num = num2[7:4];t_led_bits <= 4'b0010;end    //数码管 2 有效，且显示数值为次低 4 位     
                2:begin num = 0;t_led_bits <= 4'b0100;end    //数码管 3 有效，且显示数值为次高 4 位     
                3:begin num = 0;t_led_bits <= 4'b1000;end    //数码管 4 有效，且显示数值为最高 4 位     
                endcase    //数码管 4 有效，且显示数值为最高 4 位     
             endcase
        
        
                 
        
     D0_display myD0_display(.D0_bits(t_led_bits),.D0_NUM(num),.D0_a_to_g(a_to_g),.D0_led_bits(led_bits)) ;   
endmodule




```